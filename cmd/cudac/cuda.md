В Rust для условного включения зависимостей в зависимости от наличия CUDA можно использовать комбинацию **фич (features)** в `Cargo.toml` и условную компиляцию в коде. Вот пошаговый подход, как это сделать:

### 1. Определите фичу в `Cargo.toml`
В файле `Cargo.toml` добавьте опциональную фичу, например, `cuda`, и укажите зависимость, которая будет подключаться только при активации этой фичи. Например:

```toml
[features]
default = []
cuda = ["cudnn"]  # Назови фичу и зависимость как угодно, здесь просто пример

[dependencies]
# Обычные зависимости
serde = { version = "1.0", features = ["derive"] }

# Зависимость, которая будет подключена только с фичей `cuda`
cudnn = { version = "0.1", optional = true }  # Пример зависимости для CUDA
```

Здесь `cudnn` — это условная зависимость, которая включается только если активирована фича `cuda`. Поле `optional = true` делает зависимость необязательной.

### 2. Используйте условную компиляцию в коде
В исходном коде Rust можно использовать атрибут `#[cfg(feature = "cuda")]` для условной компиляции кода, связанного с CUDA. Например:

```rust
fn main() {
    println!("Программа запущена!");

    #[cfg(feature = "cuda")]
    {
        println!("CUDA включена, используем cudnn!");
        // Здесь код, зависящий от CUDA
    }

    #[cfg(not(feature = "cuda"))]
    {
        println!("CUDA не включена, работаем без нее.");
    }
}
```

### 3. Укажи пользователям, как включить фичу
Чтобы включить фичу `cuda` при сборке, нужно использовать флаг `--features` в команде `cargo build` или `cargo run`. Например:

```bash
cargo build --bin cudac --features cuda --release
```
Но почему Device::cuda_is_available(0) возвращает false?
А потому, что самой candle-core зависимости требуется features = ["cuda"] 
```toml
candle-core = { workspace = true, optional = true , features = ["cuda"]}
```
Компиляция "nvcc" "--gpu-architecture=sm_61" падает:
nvcc error while compiling "src\\affine.cu"

nvidia-smi --query-gpu=compute_cap --format=csv,noheader
выдает 6.1, а надо : We need compute_cap>7.0 for it to work.
Но карта 1070Ti поддерживает только 6.1
на 9444 тоже 6.1 и cuda 12.4.1

Если в features вставить "candel-core/cuda", то это аналогично добавлению features = ["cuda"] в саму candle-core

------------
Если фича не указана, зависимость `cudnn` не будет подключена, и код под `#[cfg(feature = "cuda")]` не будет скомпилирован.

### 4. Опционально: автоматическое определение CUDA
Если ты хочешь, чтобы наличие CUDA определялось автоматически (например, через проверку окружения или доступности библиотек), это потребует дополнительных усилий:
- Напиши скрипт в `build.rs`, который проверяет наличие CUDA (например, через переменные окружения вроде `CUDA_PATH` или вызов `nvcc --version`).
- В зависимости от результата задавай фичу через `cargo:rerun-if-changed` или вывод условий для компиляции.

Пример `build.rs`:

```rust
use std::process::Command;

fn main() {
    let cuda_available = Command::new("nvcc")
        .arg("--version")
        .output()
        .is_ok();

    if cuda_available {
        println!("cargo:rustc-cfg=cuda");
    }
}
```

Тогда в коде можно использовать `#[cfg(cuda)]` вместо `#[cfg(feature = "cuda")]`, и это будет зависеть от результата проверки в `build.rs`.

### Итог
Самый простой и гибкий способ — это использование фич в `Cargo.toml` с ручным включением через `--features cuda`. Если нужно автоматизировать проверку CUDA, добавь логику в `build.rs`. Выбери подход в зависимости от того, хочешь ли ты перекладывать ответственность за выбор на пользователя или делать это автоматически.

